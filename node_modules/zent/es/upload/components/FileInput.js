import { __extends } from "tslib";
import * as React from 'react';
import { PureComponent } from 'react';
import toArray from 'lodash-es/toArray';
import forEach from 'lodash-es/forEach';
import isPromise from '../../utils/isPromise';
import { I18nReceiver as Receiver } from '../../i18n';
import Notify from '../../notify';
import { formatFileSize, base64ToArrayBuffer, formatErrorMessages, } from '../utils';
import fileType from '../utils/file-type';
import uploadLocalImage from './UploadLocal';
import { UID_KEY, DEFAULT_ACCEPT } from '../constants';
var noop = function (res) { return res; };
var FileInput = (function (_super) {
    __extends(FileInput, _super);
    function FileInput(props) {
        var _this = _super.call(this, props) || this;
        _this.onFileChange = function (localFiles) {
            var onChange = _this.props.onChange;
            if (onChange) {
                onChange(localFiles);
            }
            else {
                uploadLocalImage(_this.props, {
                    localFiles: localFiles,
                });
            }
        };
        _this.processFiles = function (i18n) { return function (evt) {
            var files = toArray(evt.target.files);
            var _a = _this.props, filterFiles = _a.filterFiles, onError = _a.onError;
            var filterResult = filterFiles(files);
            var iterator = _this.iteratorFiles(i18n);
            if (isPromise(filterResult)) {
                filterResult.then(iterator, onError);
            }
            else {
                files = filterResult;
                iterator(files);
            }
            evt.target.value = null;
        }; };
        _this.iteratorFiles = function (i18n) { return function (files) {
            var _a = _this.props, type = _a.type, maxSize = _a.maxSize, maxAmount = _a.maxAmount, silent = _a.silent, initIndex = _a.initIndex, errorMessages = _a.errorMessages;
            forEach(files, function (file, index) {
                if (maxAmount && index + initIndex >= maxAmount) {
                    var message = formatErrorMessages(errorMessages.overMaxAmount, { maxAmount: maxAmount, type: type }, i18n.input.maxAmount);
                    !silent && message && Notify.error(message);
                    return false;
                }
                if (!maxSize || file.size <= maxSize) {
                    _this.addFile(file, index, i18n);
                }
                else {
                    var message = formatErrorMessages(errorMessages.overMaxSize, {
                        maxSize: formatFileSize(maxSize),
                        type: type,
                    }, i18n.input.maxSize);
                    !silent && message && Notify.error(message);
                }
                return true;
            });
        }; };
        _this.autoShowInput = function (fileInput) {
            var _a = _this.props, maxAmount = _a.maxAmount, auto = _a.auto;
            if (auto &&
                maxAmount === 1 &&
                fileInput &&
                typeof fileInput.click === 'function') {
                fileInput.click();
            }
        };
        var accept = props.accept, type = props.type;
        if (!accept) {
            accept = DEFAULT_ACCEPT[type];
        }
        _this.state = {
            accept: accept,
        };
        return _this;
    }
    FileInput.prototype.addFile = function (file, index, i18n) {
        var _this = this;
        var fileReader = new FileReader();
        var _a = this.props, type = _a.type, initIndex = _a.initIndex, silent = _a.silent, errorMessages = _a.errorMessages;
        var accept = this.state.accept;
        var localFiles = [];
        fileReader.onload = function (e) {
            var _a;
            var mimeType = fileType(base64ToArrayBuffer(e.target.result.replace(/^(.*?)base64,/, '')));
            if (accept &&
                (!mimeType ||
                    mimeType.mime.match(new RegExp(accept.replace(/, ?/g, '|'))))) {
                localFiles.push((_a = {
                        src: e.target.result,
                        file: file
                    },
                    _a[UID_KEY] = initIndex + index,
                    _a));
            }
            else {
                var message = formatErrorMessages(errorMessages.wrongMimeType, { type: type }, i18n.input.type);
                !silent && message && Notify.error(message);
            }
            _this.onFileChange(localFiles);
        };
        fileReader.readAsDataURL(file);
    };
    FileInput.prototype.render = function () {
        var _this = this;
        var maxAmount = this.props.maxAmount;
        var accept = this.state.accept;
        return (React.createElement(Receiver, { componentName: "Upload" }, function (i18n) { return (React.createElement("input", { ref: _this.autoShowInput, type: "file", placeholder: i18n.input.holder + " +", multiple: maxAmount !== 1, accept: accept, onChange: _this.processFiles(i18n) })); }));
    };
    FileInput.defaultProps = {
        initIndex: 0,
        maxAmount: 0,
        silent: false,
        maxSize: 0,
        type: '',
        filterFiles: noop,
        onError: noop,
    };
    return FileInput;
}(PureComponent));
export default FileInput;
