import { __assign, __extends } from "tslib";
import * as React from 'react';
import { PureComponent } from 'react';
import classnames from 'classnames';
import has from 'lodash-es/has';
import get from 'lodash-es/get';
import every from 'lodash-es/every';
import assign from 'lodash-es/assign';
import debounce from 'lodash-es/debounce';
import isEqual from 'lodash-es/isEqual';
import forEach from 'lodash-es/forEach';
import noop from 'lodash-es/noop';
import size from 'lodash-es/size';
import some from 'lodash-es/some';
import map from 'lodash-es/map';
import isFunction from 'lodash-es/isFunction';
import includes from 'lodash-es/includes';
import measureScrollbar from '../utils/dom/measureScrollbar';
import WindowResizeHandler from '../utils/component/WindowResizeHandler';
import { I18nReceiver as Receiver } from '../i18n';
import { groupedColumns, getLeafColumns } from './utils';
import BlockLoading from '../loading/BlockLoading';
import Store from './Store';
import ColGroup from './ColGroup';
import Header from './Header';
import Body from './Body';
import Footer from './Footer';
import SelectionCheckbox from './SelectionCheckbox';
import SelectionCheckboxAll from './SelectionCheckboxAll';
function stopPropagation(e) {
    e.stopPropagation();
    if (e.nativeEvent.stopImmediatePropagation) {
        e.nativeEvent.stopImmediatePropagation();
    }
}
var prefix = 'zent';
var Grid = (function (_super) {
    __extends(Grid, _super);
    function Grid(props) {
        var _this = _super.call(this, props) || this;
        _this.mounted = false;
        _this.checkboxPropsCache = {};
        _this.store = new Store();
        _this.tableNode = null;
        _this.bodyTable = null;
        _this.leftBody = null;
        _this.rightBody = null;
        _this.scrollBody = null;
        _this.scrollHeader = null;
        _this.syncFixedTableRowHeight = function () {
            if (!_this.mounted || !_this.tableNode) {
                return;
            }
            var tableRect = _this.tableNode.getBoundingClientRect();
            if (tableRect.height !== undefined && tableRect.height <= 0) {
                return;
            }
            var bodyRows = (_this.bodyTable &&
                _this.bodyTable.querySelectorAll("tbody ." + prefix + "-grid-tr")) ||
                [];
            var expandRows = (_this.bodyTable &&
                _this.bodyTable.querySelectorAll("tbody ." + prefix + "-grid-tr__expanded")) ||
                [];
            var headRows = _this.scrollHeader
                ? _this.scrollHeader.querySelectorAll('thead')
                : _this.bodyTable.querySelectorAll('thead');
            var fixedColumnsBodyRowsHeight = map(bodyRows, function (row) { return row.getBoundingClientRect().height || 'auto'; });
            var fixedColumnsHeadRowsHeight = map(headRows, function (row) { return row.getBoundingClientRect().height || 'auto'; });
            var fixedColumnsBodyExpandRowsHeight = map(expandRows, function (row) { return row.getBoundingClientRect().height || 'auto'; });
            if (isEqual(_this.state.fixedColumnsBodyRowsHeight, fixedColumnsBodyRowsHeight) &&
                isEqual(_this.state.fixedColumnsHeadRowsHeight, fixedColumnsHeadRowsHeight) &&
                isEqual(_this.state.fixedColumnsBodyExpandRowsHeight, fixedColumnsBodyExpandRowsHeight)) {
                return;
            }
            _this.setState({
                fixedColumnsBodyRowsHeight: fixedColumnsBodyRowsHeight,
                fixedColumnsHeadRowsHeight: fixedColumnsHeadRowsHeight,
                fixedColumnsBodyExpandRowsHeight: fixedColumnsBodyExpandRowsHeight,
            });
        };
        _this.onChange = function (conf) {
            var params = assign({}, _this.store.getState('conf'), conf);
            _this.store.setState('conf');
            _this.props.onChange && _this.props.onChange(params);
        };
        _this.onPaginationChange = function (pageSize, current) {
            _this.props.onChange &&
                _this.props.onChange({
                    pageSize: pageSize,
                    current: current,
                });
        };
        _this.getDataKey = function (data, rowIndex) {
            var rowKey = _this.props.rowKey;
            return rowKey ? get(data, rowKey) : rowIndex;
        };
        _this.isAnyColumnsFixed = function () {
            return _this.store.getState('isAnyColumnsFixed', function () {
                return some(_this.store.getState('columns'), function (column) { return !!column.fixed; });
            });
        };
        _this.isAnyColumnsLeftFixed = function () {
            return _this.store.getState('isAnyColumnsLeftFixed', function () {
                return some(_this.store.getState('columns'), function (column) { return column.fixed === 'left' || column.fixed === true; });
            });
        };
        _this.isAnyColumnsRightFixed = function () {
            return _this.store.getState('isAnyColumnsRightFixed', function () {
                return some(_this.store.getState('columns'), function (column) { return column.fixed === 'right'; });
            });
        };
        _this.getLeftColumns = function () {
            var columns = _this.store.getState('columns') || [];
            return columns.filter(function (column) { return column.fixed === 'left' || column.fixed === true; });
        };
        _this.getRightColumns = function () {
            var columns = _this.store.getState('columns') || [];
            return columns.filter(function (column) { return column.fixed === 'right'; });
        };
        _this.handleExpandRow = function (clickRow, rowData) { return function (e) {
            var onExpand = _this.props.onExpand;
            var expandRowKeys = map(_this.state.expandRowKeys, function (row, index) {
                return index === clickRow ? !row : row;
            });
            _this.store.setState({
                columns: _this.getColumns(_this.props, _this.props.columns, expandRowKeys),
            });
            _this.setState({
                expandRowKeys: expandRowKeys,
            });
            if (isFunction(onExpand)) {
                onExpand({
                    expanded: expandRowKeys[clickRow],
                    data: rowData,
                    event: e,
                    index: clickRow,
                });
            }
        }; };
        _this.getExpandBodyRender = function (expandRowKeys) { return function (rowData, _a) {
            var row = _a.row;
            return (React.createElement("span", { className: expandRowKeys[row]
                    ? prefix + "-grid-expandable-btn " + prefix + "-grid-collapse-btn"
                    : prefix + "-grid-expandable-btn " + prefix + "-grid-expand-btn", onClick: _this.handleExpandRow(row, rowData) }));
        }; };
        _this.getColumns = function (props, columnsArg, expandRowKeysArg) {
            var _a = props || _this.props, selection = _a.selection, datasets = _a.datasets, expandation = _a.expandation;
            var isStoreColumns = !columnsArg;
            var columns = (columnsArg || _this.store.getState('columns')).slice();
            var expandRowKeys = expandRowKeysArg || _this.state.expandRowKeys;
            var hasLeft = columns.some(function (column) { return column.fixed === 'left' || column.fixed === true; });
            if (selection) {
                var data = (datasets || []).filter(function (item, index) {
                    var rowIndex = _this.getDataKey(item, index);
                    if (selection.getCheckboxProps) {
                        return !get(_this.getCheckboxPropsByItem(item, rowIndex), 'disabled');
                    }
                    return true;
                });
                var checkboxAllDisabled = every(data, function (item, index) {
                    var rowIndex = _this.getDataKey(item, index);
                    return get(_this.getCheckboxPropsByItem(item, rowIndex), 'disabled');
                });
                var selectionColumn = {
                    title: (React.createElement(SelectionCheckboxAll, { store: _this.store, datasets: data, getDataKey: _this.getDataKey, onSelect: _this.handleBatchSelect, disabled: checkboxAllDisabled })),
                    key: 'selection-column',
                    width: '20px',
                    bodyRender: _this.renderSelectionCheckbox(),
                };
                if (hasLeft) {
                    selectionColumn.fixed = 'left';
                }
                if (columns[0] && columns[0].key === 'selection-column') {
                    columns[0] = __assign(__assign({}, columns[0]), selectionColumn);
                }
                else {
                    columns.unshift(selectionColumn);
                }
            }
            if (expandation) {
                var expandColumn = {
                    title: '',
                    key: 'expand-column',
                    width: '20px',
                    bodyRender: _this.getExpandBodyRender(expandRowKeys),
                };
                if (hasLeft) {
                    expandColumn.fixed = 'left';
                }
                columns.unshift(expandColumn);
            }
            if (!isStoreColumns) {
                columns = groupedColumns(columns);
            }
            return columns;
        };
        _this.getLeftFixedTable = function () {
            return _this.getTable({
                columns: _this.getLeftColumns(),
                fixed: 'left',
            });
        };
        _this.getRightFixedTable = function () {
            return _this.getTable({
                columns: _this.getRightColumns(),
                fixed: 'right',
            });
        };
        _this.handleBodyScroll = function (e) {
            if (!_this.mounted) {
                return;
            }
            if (e.currentTarget !== e.target) {
                return;
            }
            var target = e.target;
            var _a = _this.props.scroll, scroll = _a === void 0 ? {} : _a;
            var scrollTop = target.scrollTop;
            var _b = _this, leftBody = _b.leftBody, rightBody = _b.rightBody, scrollBody = _b.scrollBody;
            if (target.scrollLeft !== _this.lastScrollLeft && scroll.x) {
                if (_this.scrollHeader && target === scrollBody) {
                    _this.scrollHeader.scrollLeft = target.scrollLeft;
                }
                if (_this.scrollHeader &&
                    _this.scrollBody &&
                    target === _this.scrollHeader) {
                    _this.scrollBody.scrollLeft = target.scrollLeft;
                }
                _this.setScrollPositionClassName();
            }
            _this.lastScrollLeft = target.scrollLeft;
            if (target.scrollTop !== _this.lastScrollTop && scroll.y) {
                if (leftBody && target !== leftBody) {
                    leftBody.scrollTop = scrollTop;
                }
                if (rightBody && target !== rightBody) {
                    rightBody.scrollTop = scrollTop;
                }
                if (scrollBody && target !== scrollBody) {
                    scrollBody.scrollTop = scrollTop;
                }
                _this.lastScrollTop = target.scrollTop;
            }
        };
        _this.onResize = debounce(_this.syncFixedTableRowHeight, 500);
        _this.onRowMouseEnter = function (mouseOverRowIndex) {
            _this.setState({
                mouseOverRowIndex: mouseOverRowIndex,
            });
        };
        _this.getTable = function (options) {
            var _a;
            if (options === void 0) { options = {}; }
            var _b = _this.props, datasets = _b.datasets, _c = _b.scroll, scroll = _c === void 0 ? {} : _c, sortType = _b.sortType, sortBy = _b.sortBy, defaultSortType = _b.defaultSortType, rowClassName = _b.rowClassName, onRowClick = _b.onRowClick, ellipsis = _b.ellipsis, expandation = _b.expandation, rowKey = _b.rowKey, components = _b.components, rowProps = _b.rowProps;
            var fixed = options.fixed;
            var columns = options.columns || _this.store.getState('columns');
            var expandRowKeys = _this.state.expandRowKeys;
            var tableClassName = '';
            var bodyStyle = {};
            var tableStyle = {};
            if (fixed || scroll.x) {
                tableClassName = prefix + "-grid-fixed";
                bodyStyle.overflowX = 'auto';
            }
            if (!fixed && scroll.x) {
                tableStyle.width = scroll.x;
            }
            var header = (React.createElement(Header, { prefix: prefix, columns: columns, fixed: fixed, store: _this.store, onChange: _this.onChange, sortType: sortType, scroll: scroll, sortBy: sortBy, defaultSortType: defaultSortType, fixedColumnsHeadRowsHeight: _this.state.fixedColumnsHeadRowsHeight }));
            var leafColumns = getLeafColumns(columns);
            var body = (React.createElement(Body, { prefix: prefix, rowKey: rowKey, columns: leafColumns, datasets: datasets, expandRowKeys: expandRowKeys, mouseOverRowIndex: _this.state.mouseOverRowIndex, onRowMouseEnter: _this.onRowMouseEnter, rowClassName: rowClassName, onRowClick: onRowClick, fixed: fixed, scroll: scroll, expandRender: expandation && expandation.expandRender, fixedColumnsBodyRowsHeight: _this.state.fixedColumnsBodyRowsHeight, fixedColumnsBodyExpandRowsHeight: _this.state.fixedColumnsBodyExpandRowsHeight, components: components, rowProps: rowProps }));
            var y = scroll.y, x = scroll.x;
            if (y) {
                var scrollbarWidth = measureScrollbar();
                var headStyle = {};
                var scrollBodyStyle = {
                    maxHeight: y,
                    overflowY: 'auto',
                };
                if (scrollbarWidth > 0) {
                    headStyle.paddingBottom = 0;
                    if (!fixed && x) {
                        headStyle.marginBottom = -scrollbarWidth;
                    }
                }
                else {
                    scrollBodyStyle.marginBottom = 0;
                }
                return [
                    React.createElement("div", { key: "header", className: prefix + "-grid-header", style: headStyle, ref: function (ref) {
                            if (!fixed)
                                _this.scrollHeader = ref;
                        }, onScroll: _this.handleBodyScroll }, header),
                    React.createElement("div", { key: "body-outer", className: prefix + "-grid-body-outer" },
                        React.createElement("div", { key: "body", className: prefix + "-grid-body", style: scrollBodyStyle, ref: function (ref) {
                                _this[(fixed || 'scroll') + "Body"] = ref;
                                if (!fixed)
                                    _this.bodyTable = ref;
                            }, onScroll: _this.handleBodyScroll }, body)),
                ];
            }
            return [
                React.createElement("div", { style: bodyStyle, ref: function (ref) {
                        if (!fixed)
                            _this.bodyTable = ref;
                    }, onScroll: _this.handleBodyScroll, key: "table" },
                    React.createElement("table", { className: classnames(prefix + "-grid-table", tableClassName, (_a = {},
                            _a[prefix + "-grid-table-ellipsis"] = ellipsis,
                            _a)), style: tableStyle },
                        React.createElement(ColGroup, { columns: columns }),
                        header,
                        body)),
            ];
        };
        _this.getEmpty = function (i18n) {
            var _a = _this.props, datasets = _a.datasets, emptyLabel = _a.emptyLabel;
            if (size(datasets) === 0) {
                return (React.createElement("div", { className: prefix + "-grid-empty", key: "empty" }, emptyLabel || i18n.emptyLabel));
            }
            return null;
        };
        _this.getCheckboxPropsByItem = function (data, rowIndex) {
            var selection = _this.props.selection;
            if (!selection || !selection.getCheckboxProps) {
                return {};
            }
            if (!_this.checkboxPropsCache[rowIndex]) {
                _this.checkboxPropsCache[rowIndex] = selection.getCheckboxProps(data);
            }
            return _this.checkboxPropsCache[rowIndex];
        };
        _this.onSelectChange = function (selectedRowKeys, data) {
            var _a = _this.props, datasets = _a.datasets, selection = _a.selection;
            var onSelect = get(selection, 'onSelect');
            if (isFunction(onSelect)) {
                var selectedRows = (datasets || []).filter(function (row, i) {
                    return includes(selectedRowKeys, _this.getDataKey(row, i));
                });
                onSelect(selectedRowKeys, selectedRows, data);
            }
        };
        _this.handleSelect = function (data, rowIndex, e) {
            var checked = e.target.checked;
            var selectedRowKeys = _this.store.getState('selectedRowKeys') || [];
            if (checked) {
                selectedRowKeys = selectedRowKeys.concat(rowIndex);
            }
            else {
                selectedRowKeys = selectedRowKeys.filter(function (i) { return rowIndex !== i; });
            }
            _this.store.setState({ selectedRowKeys: selectedRowKeys });
            _this.onSelectChange(selectedRowKeys, data);
        };
        _this.handleBatchSelect = function (type, data) {
            var selectedRowKeys = _this.store.getState('selectedRowKeys').slice();
            var changeRowKeys = [];
            switch (type) {
                case 'selectAll':
                    forEach(data, function (key, index) {
                        var rowIndex = _this.getDataKey(key, index);
                        if (!includes(selectedRowKeys, rowIndex)) {
                            selectedRowKeys = selectedRowKeys.concat(rowIndex);
                            changeRowKeys.push(rowIndex);
                        }
                    });
                    break;
                case 'removeAll':
                    selectedRowKeys = (data || []).filter(function (key, index) {
                        var rowIndex = _this.getDataKey(key, index);
                        var rlt = true;
                        if (includes(selectedRowKeys, rowIndex)) {
                            rlt = false;
                            changeRowKeys.push(key);
                        }
                        return rlt;
                    });
                    break;
                default:
                    break;
            }
            _this.store.setState({ selectedRowKeys: selectedRowKeys });
            var changeRow = (data || []).filter(function (row, i) {
                return includes(changeRowKeys, _this.getDataKey(row, i));
            });
            _this.onSelectChange(selectedRowKeys, changeRow);
        };
        _this.renderSelectionCheckbox = function () {
            return function (data, _a) {
                var row = _a.row;
                var rowIndex = _this.getDataKey(data, row);
                var props = _this.getCheckboxPropsByItem(data, rowIndex);
                return (React.createElement("span", { onClick: stopPropagation },
                    React.createElement(SelectionCheckbox, { disabled: props.disabled, rowIndex: rowIndex, store: _this.store, onChange: function (e) {
                            return _this.handleSelect(data, _this.getDataKey(data, row), e);
                        } })));
            };
        };
        var expandRowKeys = _this.getExpandRowKeys(props);
        _this.store.setState({
            columns: _this.getColumns(props, props.columns, expandRowKeys),
            selectedRowKeys: get(props, 'selection.selectedRowKeys'),
        });
        _this.setScrollPosition('both');
        _this.state = {
            mouseOverRowIndex: -1,
            fixedColumnsBodyRowsHeight: [],
            fixedColumnsHeadRowsHeight: [],
            fixedColumnsBodyExpandRowsHeight: [],
            expandRowKeys: expandRowKeys,
        };
        return _this;
    }
    Grid.prototype.getExpandRowKeys = function (props) {
        var expandation = props.expandation, datasets = props.datasets;
        if (expandation) {
            var isExpanded_1 = expandation.isExpanded;
            var expandRowKeys = datasets.reduce(function (items, rowData, rowIndex) {
                if (typeof isExpanded_1 === 'function') {
                    items[rowIndex] = isExpanded_1(rowData, rowIndex);
                }
                else {
                    items[rowIndex] = false;
                }
                return items;
            }, []);
            return expandRowKeys;
        }
        return [];
    };
    Grid.prototype.setScrollPosition = function (position) {
        this.scrollPosition = position;
        if (this.tableNode) {
            if (position === 'both') {
                this.tableNode.className = this.tableNode.className.replace(new RegExp(prefix + "-grid-scroll-position-.+$", 'gi'), ' ');
                this.tableNode.classList.add(prefix + "-grid-scroll-position-left");
                this.tableNode.classList.add(prefix + "-grid-scroll-position-right");
            }
            else {
                this.tableNode.className = this.tableNode.className.replace(new RegExp(prefix + "-grid-scroll-position-.+$", 'gi'), ' ');
                this.tableNode.classList.add(prefix + "-grid-scroll-position-" + position);
            }
        }
    };
    Grid.prototype.setScrollPositionClassName = function () {
        var node = this.bodyTable;
        var scrollToLeft = node.scrollLeft === 0;
        var scrollToRight = node.scrollLeft + 1 >=
            node.children[0].getBoundingClientRect().width -
                node.getBoundingClientRect().width;
        if (scrollToLeft && scrollToRight) {
            this.setScrollPosition('both');
        }
        else if (scrollToLeft) {
            this.setScrollPosition('left');
        }
        else if (scrollToRight) {
            this.setScrollPosition('right');
        }
        else if (this.scrollPosition !== 'middle') {
            this.setScrollPosition('middle');
        }
    };
    Grid.prototype.componentDidMount = function () {
        this.mounted = true;
        this.setScrollPositionClassName();
        if (this.isAnyColumnsFixed()) {
            this.syncFixedTableRowHeight();
        }
    };
    Grid.prototype.componentWillUnmount = function () {
        this.mounted = false;
    };
    Grid.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.selection && has(nextProps.selection, 'selectedRowKeys')) {
            this.store.setState({
                selectedRowKeys: nextProps.selection.selectedRowKeys || [],
                columns: this.getColumns(nextProps),
            });
            var selection = this.props.selection;
            if (selection &&
                nextProps.selection.getCheckboxProps !== selection.getCheckboxProps) {
                this.checkboxPropsCache = {};
            }
        }
        if (nextProps.columns && nextProps.columns !== this.props.columns) {
            this.store.setState({
                columns: this.getColumns(nextProps, nextProps.columns),
            });
        }
        if (has(nextProps, 'datasets') &&
            nextProps.datasets !== this.props.datasets) {
            this.checkboxPropsCache = {};
            var expandRowKeys = this.getExpandRowKeys(nextProps);
            this.store.setState({
                columns: this.getColumns(nextProps, nextProps.columns, expandRowKeys),
            });
            this.setState({
                expandRowKeys: expandRowKeys,
            });
        }
    };
    Grid.prototype.componentDidUpdate = function () {
        if (this.isAnyColumnsFixed()) {
            this.syncFixedTableRowHeight();
        }
    };
    Grid.prototype.render = function () {
        var _this = this;
        var _a = this.props, loading = _a.loading, _b = _a.pageInfo, pageInfo = _b === void 0 ? {} : _b, paginationType = _a.paginationType, bordered = _a.bordered;
        var className = prefix + "-grid";
        var borderedClassName = bordered ? prefix + "-grid-bordered" : '';
        className = classnames(className, this.props.className, borderedClassName);
        if (this.scrollPosition === 'both') {
            className = classnames(className, prefix + "-grid-scroll-position-left", prefix + "-grid-scroll-position-right");
        }
        else {
            className = classnames(className, prefix + "-grid-scroll-position-" + this.scrollPosition);
        }
        return (React.createElement(Receiver, { componentName: "Grid" }, function (i18n) {
            var content = [
                _this.getTable(),
                _this.getEmpty(i18n),
                React.createElement(Footer, { key: "footer", prefix: prefix, pageInfo: pageInfo, paginationType: paginationType, onChange: _this.onChange, onPaginationChange: _this.onPaginationChange }),
            ];
            var scrollTable = _this.isAnyColumnsFixed() ? (React.createElement("div", { className: prefix + "-grid-scroll" }, content)) : (content);
            return (React.createElement("div", { className: className, ref: function (node) { return (_this.tableNode = node); } },
                React.createElement(BlockLoading, { loading: loading },
                    scrollTable,
                    _this.isAnyColumnsLeftFixed() && (React.createElement("div", { className: prefix + "-grid-fixed-left" }, _this.getLeftFixedTable())),
                    _this.isAnyColumnsRightFixed() && (React.createElement("div", { className: prefix + "-grid-fixed-right" }, _this.getRightFixedTable()))),
                React.createElement(WindowResizeHandler, { onResize: _this.onResize })));
        }));
    };
    Grid.defaultProps = {
        className: '',
        bordered: false,
        datasets: [],
        columns: [],
        loading: false,
        paginationType: 'default',
        onChange: noop,
        rowKey: 'id',
        emptyLabel: '',
        scroll: {},
        onRowClick: noop,
        ellipsis: false,
        onExpand: noop,
    };
    return Grid;
}(PureComponent));
export { Grid };
export default Grid;
