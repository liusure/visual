import { Observable, NextObserver } from 'rxjs';
import { BasicModel } from './models';
export declare const ASYNC_VALIDATOR: unique symbol;
export interface IAsyncValidator<T> {
    [ASYNC_VALIDATOR]: true;
    validator(input: T, ctx: ValidatorContext<T>): null | Observable<IMaybeError<T>> | Promise<IMaybeError<T>>;
}
export interface ISyncValidator<T> {
    (input: T, ctx: ValidatorContext<T>): IMaybeError<T>;
    $$id?: symbol;
}
export declare type IValidator<T> = IAsyncValidator<T> | ISyncValidator<T>;
export declare type IValidators<T> = readonly IValidator<T>[];
export declare function isAsyncValidator<T>(validator: ISyncValidator<T> | IAsyncValidator<T>): validator is IAsyncValidator<T>;
export declare function createAsyncValidator<T>(validator: () => null | Observable<IMaybeError<T>> | Promise<IMaybeError<T>>): IAsyncValidator<T>;
export interface IValidateResult<T> {
    name: string;
    message?: string;
    expect?: T;
    actual?: T;
    [key: string]: any;
}
export declare type IMaybeError<T> = IValidateResult<T> | null;
export declare enum ValidateOption {
    Empty = 0,
    IncludeAsync = 2,
    IncludeUntouched = 4,
    IncludeChildrenRecursively = 8,
    ExcludePristine = 16,
    Default = 0
}
export interface IValidation {
    option: ValidateOption;
    resolve(): void;
    reject(error?: any): void;
}
export declare class ErrorSubscriber<T> implements NextObserver<IMaybeError<T>> {
    private readonly model;
    constructor(model: BasicModel<T>);
    next(error: IMaybeError<T>): void;
}
export declare class ValidatorContext<T> {
    readonly model: BasicModel<T>;
    constructor(model: BasicModel<T>);
    getSection(): BasicModel<T>['owner'];
    getSectionValue<T>(...names: string[]): T | null;
    getFormValue<T extends object = Record<string, unknown>>(): T | null;
}
export declare function validate<T>(model: BasicModel<T>): (validation: IValidation) => Observable<IMaybeError<T>>;
//# sourceMappingURL=validate.d.ts.map