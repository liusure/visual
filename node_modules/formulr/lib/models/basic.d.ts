import { Subject, BehaviorSubject } from 'rxjs';
import { ValidateOption, IMaybeError, IValidation, IValidators } from '../validate';
import { FieldSetModel } from './set';
import { ModelRef } from './ref';
import { FormModel } from './form';
import { Maybe } from '../maybe';
interface IModel<Value> {
    getRawValue(): any;
    pristine(): boolean;
    touched(): boolean;
    dirty(): boolean;
    valid(): boolean;
    patchValue(value: Value): void;
    validate(strategy: ValidateOption): void;
    reset(): void;
    clear(): void;
    initialize(value: Value): void;
    error: IMaybeError<Value>;
}
declare const MODEL: unique symbol;
declare abstract class BasicModel<Value> implements IModel<Value> {
    /** @internal */
    id: string;
    /** @internal */
    phantomValue: Value;
    /** @internal */
    readonly validate$: Subject<IValidation>;
    /** @internal */
    validators: IValidators<Value>;
    /** @internal */
    initialValue: Maybe<Value>;
    /** @internal */
    owner: FieldSetModel<any> | ModelRef<any, any, any> | null;
    /** @internal */
    form: FormModel<any> | null;
    destroyOnUnmount: boolean;
    /** @internal */
    [MODEL]: boolean;
    abstract getRawValue(): any;
    abstract getSubmitValue(): any;
    readonly error$: BehaviorSubject<IMaybeError<Value>>;
    constructor();
    abstract pristine(): boolean;
    abstract touched(): boolean;
    abstract dirty(): boolean;
    abstract valid(): boolean;
    abstract patchValue(value: Value): void;
    abstract reset(): void;
    abstract clear(): void;
    abstract initialize(value: Value): void;
    abstract validate(option?: ValidateOption): Promise<any>;
    protected triggerValidate(option: ValidateOption): Promise<unknown>;
    error: IMaybeError<Value>;
}
declare function isModel<T>(maybeModel: any): maybeModel is BasicModel<T>;
export { IModel, BasicModel, isModel };
//# sourceMappingURL=basic.d.ts.map