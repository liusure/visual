import _isEmpty from 'lodash/isEmpty';
import _startsWith from 'lodash/startsWith';
import _uniqueId from 'lodash/uniqueId';


import { COMPONENT_GROUP_DESIGN_TYPE } from './design-type';

function DummyComponent() {
  return null;
}

export function createGroup(name) {
  return {
    type: _uniqueId(COMPONENT_GROUP_DESIGN_TYPE) + '|' + name,
    editor: DummyComponent,
    preview: DummyComponent,
    name: name
  };
}

export function isGroupComponent(component) {
  if (!component) {
    return false;
  }

  return _startsWith(component.type, COMPONENT_GROUP_DESIGN_TYPE);
}

/**
 * Check if component array is grouped.
 *
 * A grouped component array MUST have a group component as its first element.
 * @param {Array} components
 */
export function isGrouped(components) {
  // Grouped components must have at least 2 elements
  if (!components || components.length < 2) {
    return false;
  }

  var possiblyGroup = components[0];
  return isGroupComponent(possiblyGroup);
}

/**
 * Split component array into an array of groups
 *
 * @param {Array} components
 */
export function splitGroup(components) {
  if (_isEmpty(components)) {
    return [];
  }

  var lastIndex = components.length - 1;

  return components.reduce(function (state, c, idx) {
    var groups = state.groups,
        buffer = state.buffer,
        group = state.group;

    var isGroup = isGroupComponent(c);

    if (!isGroup) {
      buffer.push(c);
    }

    // When processing the last component, ensure buffer is consumed
    if (isGroup || idx === lastIndex) {
      // Empty group is ignored
      if (group && !_isEmpty(buffer)) {
        groups.push({
          group: group,
          components: buffer
        });
      }

      // Start a new group
      state.buffer = [];
      state.group = c;
    }

    return state;
  }, { groups: [], buffer: [], group: null }).groups;
}